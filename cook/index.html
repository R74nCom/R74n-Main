<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
<!--
⢠⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣄⣀⣀⠄⠄⠄⠄⠄⠄⠄⠄⣀⣀⣀⣀⣀⣀⣀⡀
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣆⡀⠄⠄⠄⠄⠿⠿⠿⠿⢿⣿⣿⠇
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠄⠄⠄⠄⠄⠄⠄⣠⣿⡿⠁⠄
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠈⠹⣿⣿⣿⣿⣧⠄⠄⠄⠄⠄⣰⣿⡿⠁⠄⠄
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⠄⠄⠄⠄⢀⣿⣿⠇⠄⠄⠄
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⢀⣿⣿⣿⣿⡟⠄⠄⠄⠄⠘⠛⠛⢀⣀⣀⠄
⢸⣿⣿⣿⣿⣤⣤⣤⣤⣤⣤⣤⣶⣾⣿⣿⣿⡿⠄⠄⠄⠄⠄⠄⢀⣴⣿⣿⣿⠄
⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⠄⠄⠄⠄⣠⣿⠟⢹⣿⣿⠄
⢸⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⣿⣯⣍⠁⠄⠄⠄⠄⠄⠄⢀⣾⣿⣉⣀⣸⣿⣿⣀
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠙⢿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⠸⠿⠿⠿⠿⢿⣿⣿⠿
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠈⣿⣿⣿⣿⣿⣆⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⠿⠿⠄
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠈⢿⣿⣿⣿⣿⣇⠄⠄⠄⠄⣿⣿⣧⣾⣿⣿⣷⡀
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠈⢻⣿⣿⣿⣿⣦⠄⠄⠄⣿⣿⡏⠄⢸⣿⣿⡇
⢸⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⢿⣿⣿⣿⣿⣆⠄⠄⣿⣿⡇⠄⢸⣿⣿⡇
⠘⠛⠛⠛⠛⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠛⠛⠛⠛⠛⠃⠄⠛⠛⠃⠄⠘⠛⠛⠃
This HTML and its contents are property of R74n.com.
-->
    <meta name="description" content="R74n">
    <meta name="keywords" content="R74n, ryan, RyanUwU, 4755">
    <meta name="author" content="R74n">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="twitter:image:alt" content="R74n">
    <meta name="twitter:image" content="https://R74n.com/icons/avatar.png">
    <title>Infinite Chef - R74n</title>
    <script type="application/ld+json">{"@context" : "http://schema.org","@type" : "Organization","name" : "R74n","url" : "https://r74n.com","sameAs" : ["https://twitter.com/R74nCom","https://twitter.com/CopyPasteDump","https://www.youtube.com/channel/UCzS6ufDfiDxbHVL001GwFeA"], "logo":"https://r74n.com/icons/favicon.png", "email":"contact@r74n.com"}</script>
    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../stylesheet.css">
    <link rel="apple-touch-icon" sizes="180x180" href="https://R74n.com/icons/apple-touch-icon.png?v=R74n-2">
    <link rel="icon" type="image/png" sizes="32x32" href="https://R74n.com/icons/favicon-32x3.png?v=R74n-2">
    <link rel="icon" type="image/png" sizes="16x16" href="https://R74n.com/icons/favicon-16x16.png?v=R74n-2">
    <link rel="manifest" href="https://R74n.com/manifest.json">
    <link rel="mask-icon" href="https://R74n.com/icons/safari-pinned-tab.svg?v=R74n-2" color="#1cd2d2">
    <link rel="shortcut icon" href="https://R74n.com/icons/favicon.ico?v=R74n-2">
    <meta name="msapplication-TileColor" content="#00ffff">
    <meta name="theme-color" content="#00ffff">
    <meta name="msapplication-config" content="https://R74n.com/icons/browserconfig.xml?v=R74n-2">

    <script src="https://R74n.com/load.js"></script>

    <script src="foodData.js"></script>

    <style>
      .content {
        margin: 0;
      }
      #textualContent {
        margin: 10px;
        margin-top: 20px;
      }
      @font-face {
        font-family: 'VT323';
        src: url('fonts/VT323-Regular.ttf') format('truetype');
      }
      #gameDiv {
        font-family: 'VT323';
        text-align: center;
        margin: auto;
        display: flex;
        flex-direction: row;
        border: solid 3px #614202;
        box-sizing: border-box;
        background-color: #614202;
        text-shadow: 0px 3px 4px rgba(0,0,0,0.25);
        position: relative;
        cursor: url("cursor_full.png"), auto;
      }
      #gameDiv button {
        cursor: url("cursor_full.png"), auto;
      }
      #gameDiv input[type="text"] {
        cursor: url("cursor_text.png"), auto;
      }
      #gameCanvasDiv {
        position: relative;
      }
      #gameCanvas {
        background-color: #e3d5ba;
        width: 100%;
        /* background image background.png, tiled, pixel art */
        background-image: url('background.png');
        background-size: 200px 200px;
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        user-select: none;
        touch-action: none;
      }
      #loadingScreen {
        background-color: #e3d5ba;
        width: 100%;
        height: 100%;
        display: flex;
        color: black;
        align-items: center;
        justify-content: center;
        z-index: 10;
      }
      #mainDiv {
        flex-direction: column;
      }
      #rightDiv {
        display: flex;
        flex-direction: column;
        background-color: #edebe6;
        height: 100%;
        border-left: solid gray 3px;
      }
      #controlsBar {
        display: flex;
        align-items: stretch;
        flex-direction: column;
        flex-grow: 1;
        height: 100%;
        box-shadow: -3px 0px 4px rgba(0,0,0,0.25);
        z-index: 7;
        user-select: none;
      }
      #controlsBar button {
        flex-grow: 1;
        border-radius: 0;
        margin: 0;
        box-shadow: none;
        border-bottom: 3px solid gray;
        background-color: #edebe6;
        color: black;
        box-sizing: border-box;
        max-height: unset;
        position: relative;
      }
      #controlsBar button img {
        /* shadow */
        filter: drop-shadow(0px 2px 1px rgba(0,0,0,0.25));
        width: 2.5em;
        max-width: unset;
      }
      #controlsBar button[selected] {
        background-color: #fff782;
        color: white;
      }
      /* last button no border */
      #controlsBar button:last-child {
        border-bottom: none;
      }
      #prepBar {
        background-color: #9b6723;
        padding: 7.5px;
        border-bottom: solid 3px #614202;
        box-sizing: border-box;
        box-shadow: 0px 3px 4px rgba(0,0,0,0.25);
        z-index: 5;
        position: relative;
        /* background-image: url('wood.png');
        background-size: 100px 100px; */
      }
      #prepBar ::placeholder {
        color: #614202;
        text-shadow: none;
        opacity: 1; /* Firefox */
      }
      #prepBar ::-ms-input-placeholder { /* Edge 12 -18 */
        color: #614202;
        text-shadow: none;
      }
      ::selection {
        background: #fffab7; /* WebKit/Blink Browsers */
      }
      ::-moz-selection {
        background: #fffab7; /* Gecko Browsers */
      }
      #prepText {
        width: 100%;
        height: 100%;
        padding: 0;
        background-color: rgba(0, 0, 0, 0);
        border: none;
        color: #edebe6;
        text-align: left;
        border-radius: 0;
        font-size: 30px;
        text-shadow: 0px 3px 4px rgba(0,0,0,0.25);
      }
      #searchResultsDiv {
        color: #edebe6;
        position: absolute;
        display: none;
        top: 48px;
        width: 100%;
        left: 0px;
        background-color: #9b6723;
        border-bottom: solid 3px #614202;
        box-sizing: border-box;
        box-shadow: 0px 3px 4px rgba(0,0,0,0.25);
        max-height: 10em;
        overflow-y: scroll;
        z-index: 6;
      }
      /* inside #searchResults, have up to 5 searchResult divs side by side */
      #searchResults {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-evenly;
      }
      .searchResult {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        padding: 5px;
        box-shadow: 0px 3px 4px rgba(0,0,0,0.25);
        border: solid 1px #775104;
        cursor: url("cursor_full.png"), auto;
        background-color: #9b6723;
        flex-grow: 1;
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }
      .searchResult:hover {
        background-color: #b78219;
      }
      .searchResult:active {
        background-color: #705019;
      }
      .searchResult img {
        width: 2em;
        height: 2em;
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        -webkit-filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
        filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
        user-drag: none;
        -webkit-user-drag: none;
      }
      .searchResult span {
        font-size: 22px;
      }


      .dialogBox {
        display: none;
        position: absolute;
        top: 49%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #9b6723;
        padding: 10px;
        padding-top: 25px;
        border: solid 3px #614202;
        box-shadow: 0px 5px 20px rgba(0,0,0,0.75);
        z-index: 9;
        min-height: 85%;
        width: 75%;
        font-size: 1.4em
      }
      .dialogBox:after {
        content: '';
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 0 55px 55px 0;
        border-color: transparent #614202 transparent transparent;
        right: -2px;
        top: -2px;
        position: absolute;
      }
      .dialogX {
        position: absolute;
        top: 7px;
        left: 7px;
        width: 48px;
        height: 48px;
        z-index: 100;
        filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
      }
      .dialogX:hover {
        filter: brightness(1.25);
      }
      #dishImage {
        height: 225px;
        display: block;
        margin: auto;
        z-index: 25;
        transform: rotate(-3deg);
        border: #edebe6 dashed 3px;
        filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
      }
      #dishNameDiv {
        background-color: #f9ecd8;
        width:80%;
        min-height: 1.5em;
        min-width:80%;
        text-align: center;
        z-index: 30;
        margin: auto;
        display:table;
        color: #434343;
        text-shadow: none;
        transform: rotate(3deg) translate(0, -15px);
      }
      #dishName {
        /*vertically align text*/
        display:table-cell;
        vertical-align:middle;
      }
      #serveUnder {
        text-align: left;
        margin-left: 10px;
      }
      #shareBlurb {
        padding-bottom: 10px;
        display: inline-block;
        color: #edebe6;
      }
      #shareIconDiv {
        vertical-align: middle;
      }
      #shareIconDiv img {
        margin-right: 3px;
        height: 1.7em;
        filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
        vertical-align: middle;
      }
      #shareIconDiv img:hover {
        filter: brightness(1.25);
      }
      #serveClearButton {
        float:right;
        margin-right: 10px;
        margin-top: 0;
        margin-bottom: 0;
        background-color: #9b6723;
        color: #edebe6;
        font-size: 1em;
        vertical-align: middle;
        height: auto;
        /* center text */
        max-height: unset;
        padding: 10px;
        box-shadow:unset;
        border-radius: 0;
        border: outset 3px #c48405;
        filter: drop-shadow(0px 3px 5px rgba(0,0,0,0.4));
      }
      
      /*
      <div id="boxContainer">
        <div class="box">Testing</div>
      </div>
      */
      #dishNameDiv {
        --mask: 
    conic-gradient(from 45deg at left,#0000,#000 1deg 89deg,#0000 90deg) left/51% 20px repeat-y,
    conic-gradient(from -135deg at right,#0000,#000 1deg 89deg,#0000 90deg) right/51% 20px repeat-y;
  -webkit-mask: var(--mask);
          mask: var(--mask);
          /* adjust: https://css-generators.com/custom-borders/ */
      }
      #boxContainer {
        background: linear-gradient(90deg,#ddd,#fff);
      }


      /* mobile */
      @media (max-width: 700px) {
        #gameDiv {
          width: 100%;
          height: 100%;
        }
        #serveClearButton {
          display: none
        }
      }
      @media (max-width: 450px) {
        .dialogBox {
          width: 90%;
        }
      }
      /* desktop */
      @media (min-width: 700px) {
      }
    </style>

</head>
<body>


<a href="https://R74n.com" class="backbutton">⦉</a>
<h1 class="pagetitle">Infinite Chef</h1>
<div class="content">


<div id="gameDiv">
  <div id="mainDiv" style="display: none;">
    <div id="prepBar">
      <input type="text" id="prepText" placeholder="Search ingredients..." autocomplete="off">
      <div id="searchResultsDiv">
        <div id="searchResults"></div>
      </div>
    </div>
    <div id="gameCanvasDiv">
      <canvas id="gameCanvas"></canvas>
      <div id="dialogBox" class="dialogBox">
        <img src="dialog_x.png" class="pixelart dialogX" onclick="hideDialog()">
        <div id="dialogContent">
          Text
        </div>
      </div>
      <div id="serveBox" class="dialogBox">
        <img src="dialog_x.png" class="pixelart dialogX" onclick="hideDialog()">
        <div id="serveContent">
          <img id="dishImage" src="background.png">
          <div id="dishNameDiv"><span id="dishName">Ketchup Mac and Cheese</span></div>
          <div id="serveUnder">
            <span id="shareBlurb">Share with the world.</span>
            <div id="shareIconDiv">
              <img src="../shapes/png/square_round.png" class="pixelart"><img src="../shapes/png/square_round.png" class="pixelart"><img src="../shapes/png/square_round.png" class="pixelart"><img src="../shapes/png/square_round.png" class="pixelart">
              <button onclick="clearView()" id="serveClearButton">Start Over</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="rightDiv" style="display: none;">
    <div id="controlsBar">
      <button selected id="button-bowl" onclick="changeView('bowl')" title="Bowl Mode"><img src="../shapes/png/semicircle_bottom.png" class="pixelart" alt="bowl"></button>
      <!-- <button id="button-stack" onclick="changeView('stack')" title="Stack Mode"><img src="../shapes/png/stack.png" class="pixelart" alt="stack"></button>
      <button id="button-stove" onclick="changeView('stove')" title="Stove Mode"><img src="../shapes/png/flame.png" class="pixelart" alt="stove"></button>
      <button id="button-blend" onclick="changeView('blend')" title="Blend Mode"><img src="../shapes/png/liquid.png" class="pixelart" alt="blend"></button> -->
      <button id="button-clear" onclick="clearView()"><img src="../shapes/png/x.png" class="pixelart"></button>
      <button id="button-done" onclick="serveDish()"><img src="green_check.png" class="pixelart"></button>
    </div>
  </div>
  <div id="loadingScreen">
    Preparing Kitchen...
  </div>
</div>

<script>
  function refreshCanvas() {
    canvas.width = gameDiv.clientWidth - document.getElementById('controlsBar').clientWidth;
    canvas.height = gameDiv.clientHeight - document.getElementById('prepBar').clientHeight - 2;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;
    drawCanvas();
  }
  var canvas = document.getElementById('gameCanvas');
  var gameDiv = document.getElementById('gameDiv');
  var mainDiv = document.getElementById('mainDiv');
  var rightDiv = document.getElementById('rightDiv');
  var ctx = canvas.getContext('2d');
  canvas.width = Math.min(700, window.innerWidth);
  canvas.height = 500;
  // set to pixelated rendering
  ctx.webkitImageSmoothingEnabled = false;
  ctx.mozImageSmoothingEnabled = false;
  ctx.imageSmoothingEnabled = false;
  gameDiv.style.height = canvas.height + 'px';
  gameDiv.style.width = canvas.width + 'px';
  mainDiv.style.height = canvas.height + 'px';
  mainDiv.style.width = canvas.width + 'px';
  if (window.innerWidth < 700) {
    // mobile scripts
  }
  else {
    // desktop scripts
  }
  fps = 40;
  gameLoop = null;
  ticks = 0;
  function tick() {
    if (!leftBound) {
      if (viewInfo[currentView] !== undefined && viewInfo[currentView].hitbox) {
        var bowlImg = loadImage(viewInfo[currentView].image);
        leftBound = Math.round(canvas.width/2 - bowlImg.width/2*5) + 50;
        rightBound = Math.round(canvas.width/2 + bowlImg.width/2*5) - 50;
        hitLine = Math.round(bowlImg.height*3 + canvas.height/2 - bowlImg.height/2*5+75);
      }
    }
    drawCanvas();
    ticks++;
  }
  imageCache = {};
  searchTimeout = null;
  currentIngredient = "";
  currentView = "bowl";
  viewData = {};
  controlState = {};
  mousePos = {x: 0, y: 0};
  foodScale = 2.25;
  function loadImage(src) {
    if (imageCache[src] == undefined) {
      imageCache[src] = new Image();
      imageCache[src].loaded = false;
      imageCache[src].onload = function() {
        this.loaded = true;
      }
      imageCache[src].src = src;
    }
    return imageCache[src];
  }
  function drawImageSized(src, top_left, bottom_right) {
    var img = loadImage(src);
    // draw image based on percentage of canvas
    ctx.drawImage(img, top_left[0] * canvas.width, top_left[1] * canvas.height, (bottom_right[0] - top_left[0]) * canvas.width, (bottom_right[1] - top_left[1]) * canvas.height);
  }
  function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;
    if (max == min) {
      h = s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return [h, s, l];
  }
  function hslToRgb(h, s, l) {
    var r, g, b;
    if (s == 0) {
      r = g = b = l; // achromatic
    } else {
      var hue2rgb = function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [r * 255, g * 255, b * 255];
  }
  function colorizeImage(src,h,s,l) {
    var name = src+h+","+s+","+l;
    if (imageCache[name]) { return imageCache[name]; }
    var img = loadImage(src);
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    if (!img.loaded) {
      if (!img.loadpilled) {
        img.addEventListener('load', function() {
          colorizeImage(src,h,s,l).src;
          this.loaded = true;
        });
        img.loadpilled = true;
      }
      img.id = name;
      return img;
    }
    var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < imgData.data.length; i += 4) {
      var rgb = [imgData.data[i], imgData.data[i+1], imgData.data[i+2]];
      var hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
      hsl[0] = Math.min(1, Math.max(0, hsl[0] + h));
      hsl[1] = Math.min(1, Math.max(0, hsl[1] + s));
      if (hsl[2] > 0.2 || l < hsl[2]) {
        hsl[2] = Math.min(1, Math.max(0, hsl[2] + l));
      }
      if (hsl[1] > 0.9) {
        hsl[1] -= Math.max(0, 0.14);
      }
      rgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
      imgData.data[i] = rgb[0];
      imgData.data[i+1] = rgb[1];
      imgData.data[i+2] = rgb[2];
    }
    ctx.putImageData(imgData, 0, 0);
    imageCache[name] = new Image();
    imageCache[name].src = canvas.toDataURL();
    imageCache[name].id = name;
    imageCache[name].addEventListener('load', function() {
      this.loaded = true;
    });
    imageCache[name].loadpilled = true;
    imageCache[name].loaded = false;
    return imageCache[name];
  }
  function colorizeStandard(src,h,s,l) {
    if (Array.isArray(h)) {
      h = h[0];
      s = s[0];
      l = l[0];
    }
    return colorizeImage(src, (h/360), (s/100-0.87), (l/100-0.56))
  }
  var imgPath = "https://r74n.com/cook/";
  function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (viewRenderer[currentView] !== undefined) { viewRenderer[currentView]() }
    tickPlaced();
    // draw a blue rectangle at the bottom of the bowl for its hitbox
    // if (viewInfo[currentView] !== undefined && viewInfo[currentView].hitbox) {
    //   var bowlImg = loadImage(viewInfo[currentView].image);
    //   var hitbox = viewInfo[currentView].hitbox;
    //   ctx.fillStyle = "rgba(0,0,255,0.5)";
    //   // relative to bowlImg width and height and its position on canvas, topleft = 0, topright = 1, bottomright = 2, bottomleft = 3, height = 4
    //   ctx.fillRect(bowlImg.width*hitbox[0] + canvas.width/2 - bowlImg.width/2*5, bowlImg.height*hitbox[1] + canvas.height/2 - bowlImg.height/2*5+75, bowlImg.width*hitbox[2], bowlImg.height*hitbox[4]);
    // }
  }
  function drawPlaced() {
    // loop through viewData[currentView].total and draw each at their x and y
    for (var i = 0; i < viewData[currentView].total.length; i++) {
      var placed = viewData[currentView].total[i];
      if (placed.hide) { continue }
      var shape = ingredientAttr(placed.id, "placedShape") || ingredients[placed.id].shape;
      var ingredientImg = colorizeStandard("../shapes/png/"+shape+".png", placed.h??ingredients[placed.id].h, placed.s??ingredients[placed.id].s, placed.l??ingredients[placed.id].l);
      if (ingredientImg.loaded === false) { continue; }
      if (placed.a < 1) {
        ctx.globalAlpha = placed.a;
      }
      ctx.drawImage(ingredientImg, placed.x - ingredientImg.width/2*foodScale, placed.y - ingredientImg.height/2*foodScale, ingredientImg.width*foodScale, ingredientImg.height*foodScale);
      if (placed.a < 1) {
        ctx.globalAlpha = 1
      }
    }
  }
  function colorIngredient(ingredient, h, s, l) {
    var info = ingredients[ingredient.id];
    if (h === undefined) {
      h = info.h;
      s = info.s;
      l = info.l;
    }
    if (Array.isArray(h)) { // select random color
      var index = Math.floor(Math.random()*h.length);
      h = h[index]; s = s[index]; l = l[index];
    }
    ingredient.h = h;
    ingredient.s = s;
    ingredient.l = l;
  }
  function changeIngredient(ingredient, newIngredient) {
    // if (!ingredients[newIngredient]) { return; }
    ingredient.id = newIngredient;
    colorIngredient(ingredient);
    containIngredient(ingredient);
  }
  function placeIngredient(ingredient, x, y) {
    var info = ingredients[ingredient];
    if (info.behavior > 0) {
      var size = 5;
    }
    else {
      var size = 32*foodScale;
    }
    var h = info.h; var s = info.s; var l = info.l;
    if (Array.isArray(info.h)) { // select random color
      var index = Math.floor(Math.random()*info.h.length);
      h = info.h[index]; s = info.s[index]; l = info.l[index];
    }
    viewData[currentView].total.push({id:ingredient, x:x, y:y, r:0, height:size*(info.height||1), width:size*0.75, h:h, s:s, l:l, a:info.a??1});
  }
  function deleteIngredient(placed) {
    for (var i = 0; i < viewData[currentView].total.length; i++) {
      if (viewData[currentView].total[i] === placed) {
        viewData[currentView].total.splice(i, 1);
        break;
      }
    }
  }
  function stainIngredient(placed, h, s, l) {
    var rgb1 = hslToRgb(placed.h/360, placed.s/100, placed.l/100);
    var rgb2 = hslToRgb(h/360, s/100, l/100);
    var rgb = [(rgb1[0] + rgb2[0])/2, (rgb1[1] + rgb2[1])/2, (rgb1[2] + rgb2[2])/2];
    var hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
    placed.h = Math.round(hsl[0]*360);
    placed.s = Math.round(hsl[1]*100);
    placed.l = Math.round(hsl[2]*100);
  }
  function choose(array) {
    if (Array.isArray(array)) {
      return array[Math.floor(Math.random()*array.length)];
    }
    return array;
  }
  function reactIngredients(placed1, placed2, params) {
    if (params.set1) {
      if (params.set1 === null) deleteIngredient(placed1);
      else changeIngredient(placed1, choose(params.set1));
    }
    if (params.set2) {
      if (params.set2 === null) deleteIngredient(placed2);
      else changeIngredient(placed2, choose(params.set2));
    }
  }
  function containIngredient(placed) {
    var info = ingredients[placed.id];
    var behavior = ingredientAttr(placed.id, "behavior");
    if (behavior > 0) {
      placed.done2 = true;
    }
    else {
      placed.done = true;
    }
    if ((behavior === 1 && viewInfo[currentView].holdsLiquid) || ((behavior === 2 || ingredientAttr(placed.id,"stain")) && viewData[currentView].liquid)) {
      viewData[currentView].liquid++;
      var rgb = hslToRgb(info.h/360, info.s/100, info.l/100);
      viewData[currentView].liquidR += rgb[0];
      viewData[currentView].liquidG += rgb[1];
      viewData[currentView].liquidB += rgb[2];
      if (behavior === 1) { placed.hide = true; }
    }
    if (ingredientAttr(placed.id,"delete") || (ingredientAttr(placed.id,"dissolve") && viewData[currentView].liquid)) {
      placed.hide = true;
    }
    // Do Reactions
    var reactions1 = ingredientAttr(placed.id, "reactions");
    for (var i = 0; i < viewData[currentView].total.length; i++) {
      var other = viewData[currentView].total[i];
      if (placed.id === other.id) { continue; }
      if (reactions1) {
        for (var key in reactions1) {
          if (ingredientIsType(other.id, key)) {
            reactIngredients(placed, other, reactions1[key]);
          }
        }
      }
      var reactions2 = ingredientAttr(other.id, "reactions");
      if (reactions2) {
        for (var key in reactions2) {
          if (ingredientIsType(placed.id, key)) {
            reactIngredients(other, placed, reactions2[key]);
          }
        }
      }
    }
  }
  function tickPlaced() {
    if (viewInfo[currentView] !== undefined && viewInfo[currentView].hitbox) {
      var bowlImg = loadImage(viewInfo[currentView].image);
      var hitbox = viewInfo[currentView].hitbox;
    }
    else {var hitbox = null}
    for (var i = 0; i < viewData[currentView].total.length; i++) {
      var placed = viewData[currentView].total[i];
      var behavior = ingredientAttr(placed.id, "behavior");
      if (placed.done || placed.done2 || placed.hide) { continue; }
      if (placed.vx === undefined) { placed.vx = 0; }
      else if (placed.vx) { placed.x += placed.vx; }
      if (placed.vy === undefined) { placed.vy = 0; }
      else if (placed.vy) { placed.y += placed.vy; }
      placed.vy += 0.5;
      // check collision with other placed
      for (var j = 0; j < viewData[currentView].total.length; j++) {
        if (i === j) { continue; }
        var other = viewData[currentView].total[j];
        if (other.hide) { continue; }
        if (placed.x < other.x + other.width/2.5 &&
            placed.x + placed.width/2.5 > other.x &&
            placed.y < (other.y + other.height/2)+5 && 
            placed.y > (other.y - other.height/2)
        ) {
        // if (placed.x < other.x + other.width/1.5 &&
        //   placed.x + placed.width/1.5 > other.x &&
        //   placed.y < other.y + other.height/1.5 &&
        //   placed.y + placed.height/1.5 > other.y) {
          // collision
          // stop ingredient if applicable
          if (other.done && placed.y > canvas.height/2.5 && placed.y < other.y && placed.x > leftBound-placed.width/2 && placed.x < rightBound+placed.width/2) {
            containIngredient(placed);
            if (ingredientAttr(placed.id,"stain")) {
              stainIngredient(other, placed.h, placed.s, placed.l);
            }
          }
          // bounce in opposite direction
          else if (placed.x < other.x) {
            // random between -5 and 0
            placed.vx = -Math.random()*5;
          }
          else {
            // random between 0 and 5
            placed.vx = Math.random()*5;
          }
        }
      }
      // if its outside the canvas, remove it
      if (placed.x < 0 || placed.x > canvas.width || placed.y > canvas.height) {
        viewData[currentView].total.splice(i, 1);
        i--;
      }
      // check collision with the bowl
      // equations: ctx.fillRect(bowlImg.width*hitbox[0] + canvas.width/2 - bowlImg.width/2*5, bowlImg.height*hitbox[1] + canvas.height/2 - bowlImg.height/2*5+75, bowlImg.width*hitbox[2], bowlImg.height*hitbox[4]);
      // if inside hitbox, set done to true
      if (hitLine) {
        // if the bottom of the placed is below the hitline, set done true
        if (placed.y + placed.height/2 >= hitLine && placed.y + placed.height/2 < hitLine+20 && placed.x > leftBound && placed.x < rightBound) {
          containIngredient(placed);
        }
      }
    }
  }
  lastLiquidColor = null;
  lastLiquidImg2 = null;
  viewRenderer = {
    "bowl": function() {
      // draw from file table.png to fit the whole canvas
      ctx.drawImage(loadImage('table.png'), 0, 0, canvas.width, canvas.height);
      // put in the middle on the table
      // drawImageSized("bowl.png", [0.25, 0.4], [0.75, 0.75]);
      ctx.shadowOffsetY = 7;
      ctx.shadowColor = "black";
      ctx.shadowBlur = 20;
      var bowlImg = loadImage('bowl.png');
      ctx.drawImage(bowlImg, canvas.width/2 - bowlImg.width/2*5, canvas.height/2 - bowlImg.height/2*5+75, bowlImg.width*5, bowlImg.height*5);
      ctx.shadowColor = "transparent";
      if (viewData.bowl.liquid) {
        var liquidColor = [viewData.bowl.liquidR/viewData.bowl.liquid, viewData.bowl.liquidG/viewData.bowl.liquid, viewData.bowl.liquidB/viewData.bowl.liquid]
        var hsl = rgbToHsl(liquidColor[0], liquidColor[1], liquidColor[2]);
        liquidColor = [Math.round(hsl[0]*360), Math.round(hsl[1]*100), Math.round(hsl[2]*100)];
        var liquidImg = colorizeStandard('bowl_liquid.png', liquidColor[0], liquidColor[1], liquidColor[2]);
        if (liquidImg.loaded === false) {
          if (lastLiquidColor) {
            liquidColor = lastLiquidColor;
            liquidImg = colorizeStandard('bowl_liquid.png', lastLiquidColor[0], lastLiquidColor[1], lastLiquidColor[2]);
          }
        }
        else {
          lastLiquidColor = liquidColor;
        }
        ctx.drawImage(liquidImg, canvas.width/2 - liquidImg.width/2*5, canvas.height/2 - liquidImg.height/2*5+75, liquidImg.width*5, liquidImg.height*5);
      }
      drawPlaced();
      // draw transparent ingredient at mousePos
      if (currentIngredient && !controlState.mobile) {
        ctx.globalAlpha = 0.5;
        var ingredientImg = colorizeStandard("../shapes/png/"+ingredients[currentIngredient].shape+".png", ingredients[currentIngredient].h, ingredients[currentIngredient].s, ingredients[currentIngredient].l);
        ctx.drawImage(ingredientImg, mousePos.x - ingredientImg.width/2*foodScale, mousePos.y - ingredientImg.height/2*foodScale, ingredientImg.width*foodScale, ingredientImg.height*foodScale);
        ctx.globalAlpha = 1;
      }
      if (viewData.bowl.liquid) {
        ctx.globalAlpha = 0.75;
        var liquidImg2 = colorizeStandard('bowl_liquid_front.png', liquidColor[0], liquidColor[1], liquidColor[2]);
        if (liquidImg2.loaded === false) {
          if (lastLiquidImg2) {
            var liquidImg2 = lastLiquidImg2;
            liquidColor = lastLiquidColor;
          }
        }
        else {
          lastLiquidImg2 = liquidImg2;
        }
        ctx.drawImage(liquidImg2, canvas.width/2 - liquidImg2.width/2*5, canvas.height/2 - liquidImg2.height/2*5+75, liquidImg2.width*5, liquidImg2.height*5);
        ctx.globalAlpha = 1;
      }
      var bowlImg2 = loadImage('bowl_front.png');
      ctx.drawImage(bowlImg2, canvas.width/2 - bowlImg.width/2*5, canvas.height/2 - bowlImg.height/2*5+75, bowlImg.width*5, bowlImg.height*5);
      // draw line in yellow
      // ctx.fillStyle = "rgba(255,255,0)";
      // ctx.fillRect(leftBound, hitLine, rightBound - leftBound, 5);
    }
  }
  viewInfo = {
    "bowl": {
      "image": "bowl.png",
      "hitbox": [0.5,3,4,1,0.5],
      "holdsLiquid": true
    }
  }
  leftBound = 0;
  rightBound = 0;
  hitLine = 0;
  function changeView(view) {
    hideDialog();
    currentView = view;
    document.getElementById('controlsBar').querySelectorAll('button[selected]').forEach(function(button) {
      button.removeAttribute('selected');
    });
    document.getElementById('controlsBar').querySelector('#button-'+view).setAttribute('selected', '');
    if (!viewData[view]) {
      viewData[view] = {"total":[],"contained":[]};
      if (viewInfo[view] !== undefined && viewInfo[view].holdsLiquid) {
        viewData[view].liquid = 0;
        viewData[view].liquidR = 0;
        viewData[view].liquidG = 0;
        viewData[view].liquidB = 0;
      }
    }
  }
  function clearView() {
    viewData[currentView].total = [];
    viewData[currentView].contained = [];
    if (viewData[currentView].liquid) {
      viewData[currentView].liquid = 0;
      viewData[currentView].liquidR = 0;
      viewData[currentView].liquidG = 0;
      viewData[currentView].liquidB = 0;
    }
    hideDialog();
  }

  function selectIngredient(ingredient,drop) {
    currentIngredient = ingredient;
    if (!ingredient || !ingredients[ingredient]) { return; }
    document.getElementById('prepText').value = formatName(ingredient);
    if (drop) {
      // random number from leftBound to rightBound
      var x = Math.random() * (rightBound - leftBound) + leftBound;
      placeIngredient(ingredient, x, 0);
    }
  }
  function formatName(ingredient) {
    if (ingredients[ingredient] !== undefined && ingredients[ingredient].name) {
      ingredient = ingredients[ingredient].name;
    }
    ingredient = ingredient.replace(/_/g, " ");
    ingredient = ingredient.replace(
      /\w\S*/g,
      function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      }
    )
    ingredient = ingredient.replace(" And ", " and ");
    ingredient = ingredient.replace(" Or ", " or ");
    ingredient = ingredient.replace(" 'N ", " 'n ");
    return ingredient;
  }
  function searchIngredients(query) {
    var searchResults = document.getElementById('searchResults');
    searchResults.innerHTML = "";
    var queryO = query.toLowerCase();
    query = queryO.replace(/[ _]+/g, "");
    if (!query) { hideSearchResults(); return; }
    var showHidden = false;
    if (query === "*test") { query = "" }
    else if (query === "*hidden") { query = ""; showHidden = true }
    var redo = false;
    var count = 0;
    var bestResults = [];
    var otherResults = [];
    var poorResults = [];
    var queryO_ = queryO.replace(/ /g, "_");
    if (ingredients[queryO_] && ingredients[queryO_].hidden) {
      bestResults.push(queryO_);
      count++;
    }
    for (var key in ingredients) {
      if (count > 10 && query.length) { break; }
      var strippedKey = key.replace(/_/g, "");
      var index = strippedKey.indexOf(query);
      if ((ingredients[key].hidden && !showHidden) || (!ingredients[key].hidden && showHidden)) { continue }
      if (index === 0) {
        bestResults.push(key);
        count++;
      }
      else if (index !== -1) {
        otherResults.push(key);
        count++;
      }
      else if (ingredients[key].keywords && ingredients[key].keywords.indexOf(query) !== -1) {
        poorResults.push(key);
        count++;
      }
    }
    // sort bestResults by length, shortest first
    bestResults.sort(function(a, b) {
      return a.length - b.length;
    });
    var results = bestResults.concat(otherResults, poorResults);
    for (var i = 0; i < results.length; i++) {
      var key = results[i];
      var info = ingredients[key];
      var canvas = colorizeStandard("../shapes/png/"+info.shape+".png", info.h, info.s, info.l);
      var div = document.createElement('div');
      div.className = 'searchResult';
      div.innerHTML = `<img src='${canvas.src}' style='opacity:${ingredientAttr(key,"a") ?? 1}'><span>${formatName(key)}</span>`;
      div.setAttribute('data-ingredient', key);
      div.onclick = function() {
        selectIngredient(this.getAttribute('data-ingredient'));
        document.getElementById('prepText').value = formatName(currentIngredient);
        document.getElementById('searchResultsDiv').style.display = 'none';
        controlState.inMenu = false;
      }
      if (canvas.loaded === false) {
        redo = true;
      }
      else {
        searchResults.appendChild(div);
      }
    }
    if (redo) {
      setTimeout(function() {
        searchIngredients(queryO);
      }, 100);
      return;
    }
    if (searchResults.innerHTML.length == 0) {
      searchResults.innerHTML = "<span>No ingredients found... :(</span>";
    }
    showSearchResults();
  }
  function addIngredient(name, data) {
    name = name.toLowerCase().replace(/ /g, "_");
    ingredients[name] = data;
    finalizeIngredient(name);
  }
  function finalizeIngredient(ingredient) {
    var info = ingredients[ingredient];
    if (info.r) {
      var r = info.r;var g = info.g;var b = info.b;
      var hsl = rgbToHsl(r, g, b);
      info.h = hsl[0] * 360;
      info.s = hsl[1] * 100;
      info.l = hsl[2] * 100;
    }
    if (info.rgb) {
      var rgb = info.rgb.split(",");
      var hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);
      info.h = hsl[0] * 360;
      info.s = hsl[1] * 100;
      info.l = hsl[2] * 100;
    }
    if (info.hsl) {
      var hsl = info.hsl.split(",");
      info.h = hsl[0];
      info.s = hsl[1];
      info.l = hsl[2];
    }
    if (info.color) {
      var colors = [];
      if (!Array.isArray(info.color)) info.color = [info.color];
      for (var i = 0; i < info.color.length; i++) {
        var color = info.color[i];
        if (color.charCodeAt(0) == 35) {
          color = color.substring(1);
        }
        var r = parseInt(color.substring(0, 2), 16);
        var g = parseInt(color.substring(2, 4), 16);
        var b = parseInt(color.substring(4, 6), 16);
        var hsl = rgbToHsl(r, g, b);
        colors.push([hsl[0] * 360, hsl[1] * 100, hsl[2] * 100]);
      }
      if (colors.length === 1) {
        info.h = colors[0][0];
        info.s = colors[0][1];
        info.l = colors[0][2];
      }
      else {
        info.h = colors.map(function(a) { return a[0] });
        info.s = colors.map(function(a) { return a[1] });
        info.l = colors.map(function(a) { return a[2] });
      }
    }
    if (!info.h) { info.h = ingredientAttr(ingredient, "h") || 0 }
    if (!info.s) { info.s = ingredientAttr(ingredient, "s") || 0 }
    if (!info.l) { info.l = ingredientAttr(ingredient, "l") || 50 }
    if (!info.shape) {
      info.shape = ingredientAttr(ingredient, "shape") || "rhombus";
    }
    else {
      if (shapeMeta.short.indexOf(info.shape) !== -1) {
        info.height = 0.5;
      }
    }
    if (!info.group) {
      var parentGroup = ingredientAttr(ingredient, "group");
      if (!parentGroup || parentGroup === "generic") {
        info.group = "other";
      }
    }
    if (info.group === "generic") { info.hidden = true }
    if (info.name) {
      info.keywords = (info.keywords||"") + info.name;
    }
    if (info.dishName) {
      info.keywords = (info.keywords||"") + info.dishName;
    }
    if (info.keywords) {
      if (Array.isArray(info.keywords)) info.keywords = info.keywords.join("");
      info.keywords = info.keywords.replace(/[_ ]+/g, "").toLowerCase();
    }
  }
  uninheritedAttributes = ["name","short"]
  function ingredientAttr(ingredient, attr) {
    if (ingredients[ingredient] === undefined) { return undefined; }
    if (ingredients[ingredient][attr] === undefined && uninheritedAttributes.indexOf(attr) === -1){
      if (ingredients[ingredient].type) {
        return ingredientAttr(ingredients[ingredient].type, attr);
      }
    }
    else {
      return ingredients[ingredient][attr];
    }
    return undefined;
  }
  function ingredientIsType(ingredient, type) {
    if (ingredient === type) { return true }
    if (ingredients[ingredient] === undefined) { return false }
    if (ingredients[ingredient].type === type) { return true }
    return ingredientIsType(ingredients[ingredient].type, type);
  }

  function generateDishName(ingredients) {
    if (!ingredients) {
      // copy the current view's ingredients
      ingredients = viewData[currentView].total.slice();
    }
    if (ingredients.length === 0) {
      return "Absolutely Nothing";
    }
    var used = {};
    var nameMap = {};
    for (var i = 0; i < ingredients.length; i++) {
      used[ingredients[i].id] = false;
      if (!nameMap[ingredients[i].id]) { nameMap[ingredients[i].id] = [] }
      nameMap[ingredients[i].id].push(ingredients[i]);
    }
    var success = true;
    var tries = 0;
    while (success && tries < 20) {
      success = false;
      for (var recipeKey in recipeMap) {
        console.log("["+recipeKey+"]")
        var recipe = recipeMap[recipeKey];
        var result = dishRecipes[recipeKey];
        var requiredCount = recipe.length;
        var count = 0;
        var toUse = {};
        for (var i = 0; i < recipe.length; i++) {
          var needed = recipe[i];
          var ingredientFound = false;
          // console.log(needed,nameMap[needed].length,(toUse[needed]||0))
          if (nameMap[needed] && nameMap[needed].length > (toUse[needed]||0)) {
            ingredientFound = true
          }
          else {
            for (var j = 0; j < ingredients.length; j++) {
              if (ingredientIsType(ingredients[j].id, needed) && !used[ingredients[j].id]) {
                if (nameMap[ingredients[j].id] && nameMap[ingredients[j].id].length > (toUse[ingredients[j].id]||0)) {
                  needed = ingredients[j].id;
                  console.log("nameMap[needed] ("+needed+"): "+nameMap[needed])
                  ingredientFound = true
                  break;
                }
              }
            }
          }
          console.log("used[needed] ("+needed+"): "+used[needed])
          console.log("ingredientFound: "+ingredientFound)
          if (ingredientFound && nameMap[needed].length) {
            toUse[needed] = (toUse[needed]||0) + 1;
            console.log(toUse[needed])
            count++;
          }
          else {
            break;
          }
        }
        if (count >= requiredCount) {
          // console.log("toUse: "+JSON.stringify(toUse))
          for (var key in toUse) {
            used[key] = true;
            // remove the amount of ingredients used
            for (var i = 0; i < toUse[key]; i++) {
              ingredients.splice(ingredients.indexOf(nameMap[key][0]), 1);
              nameMap[key].splice(0, 1);
            }
            // console.log("ingredients: "+JSON.stringify(ingredients))
            // console.log("nameMap: "+JSON.stringify(nameMap))
          }
          ingredients.push({id:result});
          if (!nameMap[result]) { nameMap[result] = [] }
          nameMap[result].push(ingredients[ingredients.length-1]);
          success = true;
        }
      }
      tries++;
    }
    // console.log(ingredients);
    console.log(used);
    // console.log(nameMap);

    var name = " ";
    var nameParts = []; //array of arrays with [string, weight]
    for (var i = 0; i < ingredients.length; i++) {
      var ingredient = ingredients[i];
      if (used[ingredient.id]) { continue }
      var skip = false;
      for (var usedIngredient in used) {
        if (used[usedIngredient] && ingredientIsType(ingredient.id, usedIngredient)) {
          skip = true;
          break;
        }
      }
      if (skip) { continue }
      var ingName = ingredient.id;
      var weight = 0;
      var type = null;
      var fallback = ingredient.id;
      var adj = ingredientAttr(ingredient.id, "adj");
      var nameOverride = ingredientAttr(ingredient.id, "name");
      var dishNameOverride = ingredientAttr(ingredient.id, "dishName");
      var weightOverride = ingredientAttr(ingredient.id, "dishWeight");
      if (weightOverride) {
        weight += weightOverride;
      }
      if (adj) {
        ingName = adj;
        weight -= 100;
        type = "adj";
      }
      else if (dishNameOverride) {
        ingName = dishNameOverride;
        weight += 100;
      }
      else if (nameOverride) {
        ingName = nameOverride;
      }
      nameParts.push([ingName, weight, type, fallback]);
      used[ingredient.id] = 2;
    }
    var nameSorted = nameParts.sort(function(b, a) {
      return b[1] - a[1];
    });
    for (var i = 0; i < nameSorted.length; i++) {
      var type = nameSorted[i][2];
      var fallback = nameSorted[i][3];
      var ingName = nameSorted[i][0];
      if (type === "adj" && i === nameSorted.length-1) {
        ingName = fallback;
      }
      if (nameParts.length >= 3 && window.ingredients[nameSorted[i][0]] && window.ingredients[nameSorted[i][0]].short) {
        nameSorted[i][0] = window.ingredients[nameSorted[i][0]].short;
      }
      name += ingName + " ";
    }
    for (var ingredient in used) {
      if (!used[ingredient] || used[ingredient] === 2) { continue }
      // used.blue_cheese = true
      // name = "mac and cheese"
      var words = ingredient.split(/[ _]+/);
      // for each amount of last x words, check regex for /^(cheese) | (cheese)$| (cheese) / and replace the group
      for (var i = 0; i < words.length; i++) {
        var oldName = name;
        var last_words = words.slice(-i).join(" ");
        // mac and cheese -> mac and blue cheese
        var regex = new RegExp("^(?:"+last_words+") | (?:"+last_words+")$| (?:"+last_words+") ", "g");
        name = name.replace(regex, " "+ingredient+" ");
        // cheeseburger -> blue cheeseburger
        var regex = new RegExp(" (?:"+last_words+")|^(?:"+last_words+")", "g");
        name = name.replace(regex, " "+ingredient);
        if (oldName !== name) {
          used[ingredient] = 2;
          break;
        }
      }
    }
    name = name.trim();
    var nameSplit = name.split(" ");
    for (var i = 0; i < nameSplit.length; i++) {
      var word = nameSplit[i];
      if (window.ingredients[word]) {
        for (var ingredient in used) {
          if (!used[ingredient] || used[ingredient] === 2) { continue }
          if (ingredientIsType(ingredient, word)) {
            nameSplit[i] = ingredient;
            break;
          }
        }
      }
    }
    name = nameSplit.join(" ");
    name = formatName(name);

    return name;
  }

  currentDialog = null;
  function showDialog(text) {
    var dialogBox = document.getElementById('dialogBox');
    var dialogContent = document.getElementById('dialogContent');
    dialogContent.innerHTML = text;
    dialogBox.style.display = 'block';
    currentDialog = 'dialogBox';
    controlState.inMenu = true;
  }
  function hideDialog() {
    if (!currentDialog) { return }
    var dialogBox = document.getElementById(currentDialog);
    dialogBox.style.display = 'none';
    currentDialog = null;
    controlState.inMenu = false;
  }
  imageGenCanvas = document.createElement('canvas');
  imageGenCanvas.width = 290;
  imageGenCanvas.height = 225;
  function serveDish() {
    var dialogBox = document.getElementById('serveBox');
    var dialogContent = document.getElementById('serveContent');
    var ctx = imageGenCanvas.getContext('2d');
    ctx.clearRect(0, 0, imageGenCanvas.width, imageGenCanvas.height);
    // copy gameCanvas image, centered and cropped
    var gameCanvas = document.getElementById('gameCanvas');
    imageGenCanvas.width = gameCanvas.width;
    imageGenCanvas.height = gameCanvas.height;
    var ctx = imageGenCanvas.getContext('2d');
    // set to pixelated rendering
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;
    // load background.png
    var bg = loadImage('background.png');

    var dishName = generateDishName();
    document.getElementById("dishName").innerText = dishName;

    // draw background.png
    var maxDimension = Math.max(imageGenCanvas.width, imageGenCanvas.height);
    ctx.drawImage(bg, 0, 0, maxDimension, maxDimension);
    ctx.drawImage(gameCanvas, 0, 0, gameCanvas.width, gameCanvas.height);
    var img = imageGenCanvas.toDataURL();
    document.getElementById("dishImage").src = img;
    dialogBox.style.display = 'block';
    currentDialog = 'serveBox';
    controlState.inMenu = true;
  }

  changeView('bowl');
  refreshCanvas();
  // window.addEventListener('resize', refreshCanvas);

  window.addEventListener('load', function(){
    document.getElementById('loadingScreen').style.display = 'none';
    document.getElementById('mainDiv').style.display = 'flex';
    document.getElementById('rightDiv').style.display = 'flex';
    var gameCanvas = document.getElementById('gameCanvas');
    var rightDiv = document.getElementById('rightDiv');
    var prepBar = document.getElementById('prepBar');
    var prepText = document.getElementById('prepText');
    var searchResults = document.getElementById('searchResultsDiv');
    var dialogBox = document.getElementById('dialogBox');
    var serveBox = document.getElementById('serveBox');

    // Event Listeners
    hideSearchResults = () => {
      document.getElementById('searchResultsDiv').style.display = 'none';
      controlState.inMenu=false;
      if (currentIngredient) { prepText.value = formatName(currentIngredient); }
    }
    showSearchResults = () => {document.getElementById('searchResultsDiv').style.display = 'block'; ; controlState.inMenu=true}
    prepText.addEventListener('focus', function(e) {
      if (document.getElementById('searchResults').innerHTML) { showSearchResults(); }
      this.value = "";
      // searchIngredients(this.value)
    });
    prepText.addEventListener('input', function(e) {
      if (this.value.length === 0) { return }
      document.getElementById('searchResults').innerHTML = "Searching... :)";
      showSearchResults();
      // timeout to prevent spamming
      if (searchTimeout) { clearTimeout(searchTimeout); }
      searchTimeout = setTimeout(function() {
        searchIngredients(prepText.value);
      }, 250);
    });
    prepText.addEventListener('keyup', function(e) {
      if (this.value.length === 0) {
        selectIngredient(null);
        hideSearchResults();
      }
      // enter key
      else if (e.keyCode == 13) {
        var searchResults = document.getElementById('searchResults');
        if (searchResults.innerHTML.length) {
          if (searchResults.children[0]) {
            searchResults.children[0].click();
            prepText.blur();
            gameCanvas.focus();
          }
        }
      }
    });
    prepBar.addEventListener('click', function(e) {
      e.stopPropagation();
      hideDialog();
    });
    document.body.addEventListener('click', function(e){
      hideSearchResults();
      if (currentDialog) {
        controlState.inMenu = true;
      }
    });
    window.addEventListener('keydown', function(e) {
      if (e.metaKey || e.ctrlKey) { return; }
      if (e.keyCode == 16) { controlState.shift = true; }
      // escape
      else if (e.keyCode == 27) {
        if (controlState.inMenu) {
          hideDialog();
          hideSearchResults();
          prepText.blur();
          gameCanvas.focus();
        }
        else {
          selectIngredient(null);
        }
      }
      // left arrow key
      else if (e.keyCode == 37) {
        var viewButton = document.getElementById("button-"+currentView);
        if (viewButton) {
          var prevButton = viewButton.previousElementSibling;
          if (prevButton) {
            var view = prevButton.id.split("-")[1];
            if (viewData[view] || viewInfo[view]) {
              changeView(view);
            }
          }
        }
      }
      // right arrow key
      else if (e.keyCode == 39) {
        var viewButton = document.getElementById("button-"+currentView);
        if (viewButton) {
          var nextButton = viewButton.nextElementSibling;
          if (nextButton) {
            var view = nextButton.id.split("-")[1];
            if (viewData[view] || viewInfo[view]) {
              changeView(view);
            }
          }
        }
      }
      // enter
      else if (e.keyCode == 13) {
        if (!controlState.inMenu) {
          serveDish();
        }
        else if (currentDialog === 'serveBox') {
          hideDialog();
        }
      }
      // if key is between a-z, 0-9, or space, backspace, focus on prepText
      if ((e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == 32 || e.keyCode == 8) {
        prepText.focus();
      }
    });
    window.addEventListener('keyup', function(e) {
      if (e.keyCode == 16) { controlState.shift = false; }
    });
    window.addEventListener('blur', function(e) {
      controlState.shift = false;
      controlState.mouse = false;
    });
    function updateMouse(e) {
      // get mouse position on canvas
      var rect = gameCanvas.getBoundingClientRect();
      mousePos = {
        x: Math.round(e.clientX - rect.left),
        y: Math.round(e.clientY - rect.top)
      }
    }
    window.addEventListener('mousemove', function(e) {
      // get mouse position on canvas
      updateMouse(e);
      // if (controlState.mouse === 0) {
      //   if (currentIngredient) {
      //     placeIngredient(currentIngredient, mousePos.x, mousePos.y);
      //   }
      // }
    });
    function mouseDown(e) {
      e.preventDefault()
      if (controlState.inMenu) {
        hideDialog();
        return;
      }
      if (controlState.mouse === 0 || e.touches) {
        if (currentIngredient) {
          placeIngredient(currentIngredient, mousePos.x, mousePos.y);
        }
      }
      if (controlState.shift) {
        console.log(mousePos.x/canvas.width,mousePos.y/canvas.height);
      }
    }
    gameCanvas.addEventListener('mousedown', function(e) {
      updateMouse(e);
      controlState.mouse = e.button;
      mouseDown(e);
    });
    gameCanvas.addEventListener('mouseup', function(e) {
      controlState.mouse = false;
    });
    window.addEventListener('mouseup', function(e) {
      controlState.mouse = false;
    });
    window.addEventListener('touchend', function(e) {
      controlState.mouse = false;
      controlState.mobile = true;
    });
    gameCanvas.addEventListener('touchstart', function(e) {
      controlState.mobile = true;
      if (e.pageX > 10 && e.pageX < window.innerWidth - 10) return;
      e.preventDefault();
      controlState.mouse = 0;
      console.log(e.touches[0])
      if (e.touches[0]) updateMouse(e.touches[0]);
      mouseDown(e)
    });
    gameCanvas.addEventListener('touchmove', function(e) { e.preventDefault(); });
    gameCanvas.addEventListener('touchend', function(e) { e.preventDefault(); });
    gameCanvas.addEventListener('touchcancel', function(e) {
      controlState.mouse = false;
      e.preventDefault();
    });

    // Initialization
    for (var key in ingredients) {
      finalizeIngredient(key);
    }
    recipeMap = {};
    // sort dishRecipes by amount of "+" in key
    var sortedKeys = Object.keys(dishRecipes).sort(function(a, b) {
      return a.split("+").length - b.split("+").length;
    });
    for (var i = 0; i < sortedKeys.length; i++) {
      recipeMap[sortedKeys[i]] = sortedKeys[i].split("+");
    }
    refreshCanvas();
    gameLoop = setInterval(tick, 1000 / fps);
  });
</script>

<div id="textualContent">
  <h2>About Infinite Chef</h2>
  <p>Test</p>
</div>







</div>


<!-- i like having this but ublock blocks these things anyway -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-93720349-6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-93720349-6');
</script>

</body>
</html>